Steps for Spring Boot (Backend):

Create a Spring Boot project with necessary dependencies: Spring Web, Spring Data JPA, Validation, and a database driver (e.g., H2 for simplicity).

Create a User entity.

Create a UserRepository for CRUD operations.

Create a UserDTO (Data Transfer Object) for the request body, with validation annotations.

Create a Controller (UserController) with a POST endpoint to add a new user, using validation on the DTO.

Handle validation errors and return appropriate responses.

Steps for React JS (Frontend):

Create a React component with a form for user details (e.g., name, email, password, etc.).

Use state to manage the form inputs and errors.

Handle form submission by sending a POST request to the Spring Boot backend.

Perform basic frontend validation and display errors from the backend.

Let's start with the Spring Boot code:

Note: We assume you have a basic Spring Boot project set up.

Spring Boot Code:

Dependencies (pom.xml for Maven or build.gradle for Gradle). Here is a snippet for Maven:

<dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-validation</artifactId> </dependency> <dependency> <groupId>com.h2database</groupId> <artifactId>h2</artifactId> <scope>runtime</scope> </dependency> <!-- Other dependencies as needed --> </dependencies>
User Entity (User.java):

We'll keep it simple with id, name, email, and password.

UserRepository (UserRepository.java):

UserDTO (UserDTO.java) for the request with validation.

Controller (UserController.java) to handle the POST request.

Global Exception Handler to handle validation errors and return a consistent error response.

Let's write the code step by step.

Step 2: User Entity (User.java)

I'll provide a complete example of React.js frontend with form validation and Spring Boot backend for user registration.

Spring Boot Backend
1. Maven Dependencies (pom.xml)
xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
2. User Entity (User.java)
java
package com.example.demo.entity;

import javax.persistence.*;
import javax.validation.constraints.*;
import lombok.Data;

@Entity
@Table(name = "users")
@Data
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    @Column(unique = true)
    private String username;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Please provide a valid email address")
    @Column(unique = true)
    private String email;
    
    @NotBlank(message = "Password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String password;
    
    @Pattern(regexp = "^[0-9]{10}$", message = "Phone number must be 10 digits")
    private String phone;
    
    @Min(value = 18, message = "Age must be at least 18")
    @Max(value = 100, message = "Age must be less than 100")
    private Integer age;
}
3. User DTO (UserDTO.java)
java
package com.example.demo.dto;

import javax.validation.constraints.*;
import lombok.Data;

@Data
public class UserDTO {
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50)
    private String username;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
    
    @NotBlank(message = "Password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String password;
    
    private String confirmPassword;
    
    @Pattern(regexp = "^[0-9]{10}$", message = "Phone number must be 10 digits")
    private String phone;
    
    @Min(value = 18, message = "Age must be at least 18")
    @Max(value = 100, message = "Age must be less than 100")
    private Integer age;
}
4. Validation Error Response (ErrorResponse.java)
java
package com.example.demo.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;
import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorResponse {
    private int status;
    private String message;
    private LocalDateTime timestamp;
    private Map<String, String> errors;
}
5. Repository (UserRepository.java)
java
package com.example.demo.repository;

import com.example.demo.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    Optional<User> findByUsername(String username);
    boolean existsByEmail(String email);
    boolean existsByUsername(String username);
}
6. Service (UserService.java)
java
package com.example.demo.service;

import com.example.demo.dto.UserDTO;
import com.example.demo.entity.User;
import com.example.demo.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;

@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User registerUser(UserDTO userDTO) {
        // Check if passwords match
        if (!userDTO.getPassword().equals(userDTO.getConfirmPassword())) {
            throw new RuntimeException("Passwords do not match");
        }
        
        // Check if email exists
        if (userRepository.existsByEmail(userDTO.getEmail())) {
            throw new RuntimeException("Email already exists");
        }
        
        // Check if username exists
        if (userRepository.existsByUsername(userDTO.getUsername())) {
            throw new RuntimeException("Username already exists");
        }
        
        // Convert DTO to Entity
        User user = new User();
        user.setUsername(userDTO.getUsername());
        user.setEmail(userDTO.getEmail());
        user.setPassword(userDTO.getPassword()); // In real app, encrypt password
        user.setPhone(userDTO.getPhone());
        user.setAge(userDTO.getAge());
        
        return userRepository.save(user);
    }
}
7. Controller (UserController.java)
java
package com.example.demo.controller;

import com.example.demo.dto.UserDTO;
import com.example.demo.dto.ErrorResponse;
import com.example.demo.entity.User;
import com.example.demo.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.*;
import javax.validation.Valid;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/users")
@CrossOrigin(origins = "http://localhost:3000") // React app origin
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @PostMapping("/register")
    public ResponseEntity<?> registerUser(@Valid @RequestBody UserDTO userDTO, 
                                          BindingResult bindingResult) {
        
        // Check for validation errors
        if (bindingResult.hasErrors()) {
            Map<String, String> errors = new HashMap<>();
            for (FieldError error : bindingResult.getFieldErrors()) {
                errors.put(error.getField(), error.getDefaultMessage());
            }
            
            ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Validation failed",
                LocalDateTime.now(),
                errors
            );
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
        
        try {
            User registeredUser = userService.registerUser(userDTO);
            return ResponseEntity.status(HttpStatus.CREATED).body(registeredUser);
        } catch (RuntimeException e) {
            ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                e.getMessage(),
                LocalDateTime.now(),
                null
            );
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
}
8. Global Exception Handler
java
package com.example.demo.handler;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationExceptions(
            MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage()));
        return ResponseEntity.badRequest().body(errors);
    }
}
9. application.properties
properties
# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/your_database
spring.datasource.username=root
spring.datasource.password=your_password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

# Server Configuration
server.port=8080
React.js Frontend
1. Install Dependencies
bash
npm install axios formik yup
2. UserService.js (API Service)
javascript
import axios from 'axios';

const API_URL = 'http://localhost:8080/api/users';

class UserService {
    registerUser(userData) {
        return axios.post(`${API_URL}/register`, userData);
    }
}

export default new UserService();
3. RegisterForm.jsx (Main Component)
javascript
import React, { useState } from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import UserService from '../services/UserService';

const RegisterForm = () => {
    const [message, setMessage] = useState('');
    const [isError, setIsError] = useState(false);
    const [validationErrors, setValidationErrors] = useState({});

    // Validation Schema
    const validationSchema = Yup.object().shape({
        username: Yup.string()
            .min(3, 'Username must be at least 3 characters')
            .max(50, 'Username must be less than 50 characters')
            .required('Username is required'),
        email: Yup.string()
            .email('Invalid email format')
            .required('Email is required'),
        password: Yup.string()
            .min(6, 'Password must be at least 6 characters')
            .required('Password is required'),
        confirmPassword: Yup.string()
            .oneOf([Yup.ref('password'), null], 'Passwords must match')
            .required('Confirm Password is required'),
        phone: Yup.string()
            .matches(/^[0-9]{10}$/, 'Phone number must be 10 digits'),
        age: Yup.number()
            .min(18, 'Age must be at least 18')
            .max(100, 'Age must be less than 100')
            .required('Age is required')
    });

    // Initial Values
    const initialValues = {
        username: '',
        email: '',
        password: '',
        confirmPassword: '',
        phone: '',
        age: ''
    };

    // Handle Form Submission
    const handleSubmit = async (values, { setSubmitting, resetForm }) => {
        try {
            setMessage('');
            setValidationErrors({});
            setIsError(false);

            const response = await UserService.registerUser(values);
            
            setMessage('User registered successfully!');
            setIsError(false);
            resetForm();
            
            console.log('Registration successful:', response.data);
            
        } catch (error) {
            setIsError(true);
            
            if (error.response) {
                // Backend validation errors
                if (error.response.data.errors) {
                    setValidationErrors(error.response.data.errors);
                } else if (error.response.data.message) {
                    setMessage(error.response.data.message);
                } else {
                    setMessage('Registration failed. Please try again.');
                }
            } else if (error.request) {
                setMessage('No response from server. Please check your connection.');
            } else {
                setMessage('An error occurred: ' + error.message);
            }
            
            console.error('Registration error:', error);
        } finally {
            setSubmitting(false);
        }
    };

    return (
        <div className="container mt-5">
            <div className="row justify-content-center">
                <div className="col-md-6">
                    <div className="card">
                        <div className="card-header">
                            <h3 className="text-center">User Registration</h3>
                        </div>
                        <div className="card-body">
                            {/* Display Messages */}
                            {message && (
                                <div className={`alert ${isError ? 'alert-danger' : 'alert-success'}`}>
                                    {message}
                                </div>
                            )}

                            <Formik
                                initialValues={initialValues}
                                validationSchema={validationSchema}
                                onSubmit={handleSubmit}
                            >
                                {({ isSubmitting, errors, touched }) => (
                                    <Form>
                                        {/* Username */}
                                        <div className="form-group mb-3">
                                            <label htmlFor="username">Username *</label>
                                            <Field 
                                                type="text" 
                                                name="username" 
                                                className={`form-control ${(errors.username && touched.username) || validationErrors.username ? 'is-invalid' : ''}`}
                                            />
                                            <ErrorMessage name="username" component="div" className="invalid-feedback" />
                                            {validationErrors.username && (
                                                <div className="invalid-feedback d-block">{validationErrors.username}</div>
                                            )}
                                        </div>

                                        {/* Email */}
                                        <div className="form-group mb-3">
                                            <label htmlFor="email">Email *</label>
                                            <Field 
                                                type="email" 
                                                name="email" 
                                                className={`form-control ${(errors.email && touched.email) || validationErrors.email ? 'is-invalid' : ''}`}
                                            />
                                            <ErrorMessage name="email" component="div" className="invalid-feedback" />
                                            {validationErrors.email && (
                                                <div className="invalid-feedback d-block">{validationErrors.email}</div>
                                            )}
                                        </div>

                                        {/* Password */}
                                        <div className="form-group mb-3">
                                            <label htmlFor="password">Password *</label>
                                            <Field 
                                                type="password" 
                                                name="password" 
                                                className={`form-control ${(errors.password && touched.password) || validationErrors.password ? 'is-invalid' : ''}`}
                                            />
                                            <ErrorMessage name="password" component="div" className="invalid-feedback" />
                                            {validationErrors.password && (
                                                <div className="invalid-feedback d-block">{validationErrors.password}</div>
                                            )}
                                        </div>

                                        {/* Confirm Password */}
                                        <div className="form-group mb-3">
                                            <label htmlFor="confirmPassword">Confirm Password *</label>
                                            <Field 
                                                type="password" 
                                                name="confirmPassword" 
                                                className={`form-control ${(errors.confirmPassword && touched.confirmPassword) ? 'is-invalid' : ''}`}
                                            />
                                            <ErrorMessage name="confirmPassword" component="div" className="invalid-feedback" />
                                        </div>

                                        {/* Phone */}
                                        <div className="form-group mb-3">
                                            <label htmlFor="phone">Phone Number</label>
                                            <Field 
                                                type="text" 
                                                name="phone" 
                                                className={`form-control ${(errors.phone && touched.phone) || validationErrors.phone ? 'is-invalid' : ''}`}
                                            />
                                            <ErrorMessage name="phone" component="div" className="invalid-feedback" />
                                            {validationErrors.phone && (
                                                <div className="invalid-feedback d-block">{validationErrors.phone}</div>
                                            )}
                                        </div>

                                        {/* Age */}
                                        <div className="form-group mb-3">
                                            <label htmlFor="age">Age *</label>
                                            <Field 
                                                type="number" 
                                                name="age" 
                                                className={`form-control ${(errors.age && touched.age) || validationErrors.age ? 'is-invalid' : ''}`}
                                            />
                                            <ErrorMessage name="age" component="div" className="invalid-feedback" />
                                            {validationErrors.age && (
                                                <div className="invalid-feedback d-block">{validationErrors.age}</div>
                                            )}
                                        </div>

                                        {/* Submit Button */}
                                        <div className="d-grid gap-2">
                                            <button 
                                                type="submit" 
                                                className="btn btn-primary"
                                                disabled={isSubmitting}
                                            >
                                                {isSubmitting ? 'Registering...' : 'Register'}
                                            </button>
                                        </div>
                                    </Form>
                                )}
                            </Formik>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default RegisterForm;
4. App.js (Main App Component)
javascript
import React from 'react';
import RegisterForm from './components/RegisterForm';
import 'bootstrap/dist/css/bootstrap.min.css';

function App() {
    return (
        <div className="App">
            <RegisterForm />
        </div>
    );
}

export default App;
5. axios Setup (src/index.js or App.js)
javascript
import axios from 'axios';

// Set base URL for all requests
axios.defaults.baseURL = 'http://localhost:8080';

// Add request interceptor for adding auth token if needed
axios.interceptors.request.use(
    config => {
        const token = localStorage.getItem('token');
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    error => Promise.reject(error)
);

// Add response interceptor for handling errors globally
axios.interceptors.response.use(
    response => response,
    error => {
        if (error.response?.status === 401) {
            // Handle unauthorized
            localStorage.removeItem('token');
            window.location = '/login';
        }
        return Promise.reject(error);
    }
);
Database Setup
MySQL Schema
sql
CREATE DATABASE your_database;

USE your_database;

CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    phone VARCHAR(10),
    age INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
Key Features:
Frontend Validation: Using Formik + Yup for client-side validation

Backend Validation: Using Spring Boot's @Valid annotations

Error Handling: Comprehensive error responses from both frontend and backend

CORS Configuration: Enabled for React app (localhost:3000)

Password Confirmation: Both client and server-side checks

Unique Constraints: Email and username uniqueness validation

Running the Application:
Start Spring Boot:

bash
mvn spring-boot:run
Start React App:

bash
npm start
Test Endpoint:

React App: http://localhost:3000

API: http://localhost:8080/api/users/register

This setup provides complete validation at both client and server levels with proper error feedback to users.
